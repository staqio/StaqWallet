// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.3.3.20 clang-1700.6.3.2)
// swift-module-flags: -target x86_64-apple-ios16.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name StaqWallet
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import AVFoundation
import AudioToolbox
import SystemConfiguration.CaptiveNetwork
import Combine
import CommonCrypto
import DeveloperToolsSupport
import DocumentReader
import FaceSDK
import Foundation
import LinkPresentation
import LocalAuthentication
import NetworkExtension
import PassKit
import Security
@_exported import StaqWallet
import Swift
import SwiftUI
import SystemConfiguration
import TrustlessSDK
import UIKit
import WebKit
import _Concurrency
import _PassKit_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
import _WebKit_SwiftUI
extension TrustlessSDK.Card : @retroactive Swift.Hashable, @retroactive Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: TrustlessSDK.Card, rhs: TrustlessSDK.Card) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustlessSDK.CardTransaction : @retroactive Swift.Hashable, @retroactive Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: TrustlessSDK.CardTransaction, rhs: TrustlessSDK.CardTransaction) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustlessSDK.Account : @retroactive Swift.Identifiable, @retroactive Swift.Hashable, @retroactive Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: TrustlessSDK.Account, rhs: TrustlessSDK.Account) -> Swift.Bool
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustlessSDK.AccountTransaction : @retroactive Swift.Identifiable, @retroactive Swift.Hashable, @retroactive Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: TrustlessSDK.AccountTransaction, rhs: TrustlessSDK.AccountTransaction) -> Swift.Bool
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}





public struct StaqWalletPaymentOrder {
  public struct OrderStatus {
    public var code: Swift.String
    public var name: Swift.String
    public var label: Swift.String
    public var labelAr: Swift.String
    public init(code: Swift.String, name: Swift.String, label: Swift.String, labelAr: Swift.String)
  }
  public var orderId: Swift.String
  public var orderType: Swift.String
  public var createdAt: Swift.String?
  public var status: StaqWallet.StaqWalletPaymentOrder.OrderStatus
  public var errorDescription: Swift.String?
  public var currency: Swift.String
  public var totalAmount: Swift.Double
  public var feesAmount: Swift.Double?
  public var taxAmount: Swift.Double?
  public var localCurrencyAmount: Swift.Double
  public var exchangeRate: Swift.Double
  public var transactionId: Swift.String?
  public var externalUniqueIdentifier: Swift.String?
  public var orderMetaData: [Swift.String : Any]?
}
public struct StaqWalletTier0 {
  public enum WalletSourceType : Swift.String {
    case wallet
    case account
    case card
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct WalletBalance {
    public let currency: Swift.String
    public let currentBalance: Swift.Double
    public let blockedAmount: Swift.Double
    public let availableBalance: Swift.Double
    public init(currency: Swift.String, currentBalance: Swift.Double, blockedAmount: Swift.Double, availableBalance: Swift.Double)
  }
  public struct WalletTransaction {
    public let id: Swift.String
    public let type: Swift.String
    public let amount: Swift.Double
    public let currency: Swift.String
    public let description: Swift.String
    public let date: Swift.String
    public let time: Swift.String
    public init(id: Swift.String, type: Swift.String, amount: Swift.Double, currency: Swift.String, description: Swift.String, date: Swift.String, time: Swift.String)
  }
  public let id: Swift.String
  public let sourceType: StaqWallet.StaqWalletTier0.WalletSourceType
  public var balance: StaqWallet.StaqWalletTier0.WalletBalance {
    get
  }
  public var transactions: [StaqWallet.StaqWalletTier0.WalletTransaction] {
    get
  }
  public init(id: Swift.String, sourceType: StaqWallet.StaqWalletTier0.WalletSourceType, balance: StaqWallet.StaqWalletTier0.WalletBalance, transactions: [StaqWallet.StaqWalletTier0.WalletTransaction])
}
@_hasMissingDesignatedInitializers final public class StaqTier0Wallet {
  public enum WalletError : Foundation.LocalizedError {
    case notInitialized
    case unauthorizedTierState
    case walletDoesNotExist
    case server(_: Swift.String)
    case unknown
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
  }
  public struct PaymentOrderParams {
    public let idempotencyKey: Swift.String
    public let externalId: Swift.String?
    public let totalAmount: Swift.Double
    public let feesAmount: Swift.Double?
    public let taxAmount: Swift.Double?
    public let currency: Swift.String
    public let supplierId: Swift.String
    public let metaData: [Swift.String : Swift.String]
    public let entityId: Swift.String
    public let userId: Swift.String
    public let serviceId: Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public init(idempotencyKey: Swift.String = UUID().uuidString, externalId: Swift.String? = nil, totalAmount: Swift.Double, feesAmount: Swift.Double? = nil, taxAmount: Swift.Double? = nil, supplierId: Swift.String, metaData: [Swift.String : Swift.String] = [:], entityId: Swift.String, userId: Swift.String, serviceId: Swift.String)
    #endif
  }
  public static func getWallet(forUser user: StaqWallet.StaqWalletUser) async throws -> StaqWallet.StaqWalletTier0
  public static func createPaymentOrder(forUser user: StaqWallet.StaqWalletUser, params: StaqWallet.StaqTier0Wallet.PaymentOrderParams) async throws -> StaqWallet.StaqWalletPaymentOrder
  public static func makeTopUpView(user: StaqWallet.StaqWalletUser, onClose: @escaping () -> Swift.Void) -> some SwiftUICore.View
  
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StaqWalletPay {
  public static func createPaymentOrder(forUser userConfig: StaqWallet.StaqWalletUser, params: StaqWallet.StaqWalletPay.PaymentOrderParams) async throws -> TrustlessSDK.CreatePaymentOrderResponse
  public static func getPaymentOrderDetails(forUser userConfig: StaqWallet.StaqWalletUser, orderId: Swift.String) async throws -> TrustlessSDK.PaymentOrderDetails
  @objc deinit
}
extension StaqWallet.StaqWalletPay {
  public enum WalletPayError : Foundation.LocalizedError {
    case notInitialized
    case notLoggedIn
    case walletNotAvailable
    case server(code: Swift.String, message: Swift.String)
    case unexpected
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
  }
  public struct PaymentOrderParams {
    public let idempotencyKey: Swift.String
    public let externalId: Swift.String?
    public let totalAmount: Swift.Double
    public let feesAmount: Swift.Double?
    public let taxAmount: Swift.Double?
    public let currency: Swift.String
    public let supplierId: Swift.String
    public let metaData: [Swift.String : Swift.String]
    #if compiler(>=5.3) && $NonescapableTypes
    public init(idempotencyKey: Swift.String = UUID().uuidString, externalId: Swift.String? = nil, totalAmount: Swift.Double, feesAmount: Swift.Double? = nil, taxAmount: Swift.Double? = nil, supplierId: Swift.String, metaData: [Swift.String : Swift.String] = [:])
    #endif
  }
}
public struct StaqWalletConfig {
  public init(merchantIdentifier: Swift.String, language: StaqWallet.SupportedLanguage, walletEnv: StaqWallet.StaqWalletEnvironment = .production)
}
public enum StaqWalletEnvironment {
  case development
  case production
  public static func == (a: StaqWallet.StaqWalletEnvironment, b: StaqWallet.StaqWalletEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class StaqWalletManager {
  @_Concurrency.MainActor public static func initialize(withConfig config: StaqWallet.StaqWalletConfig)
  @_Concurrency.MainActor public static func changeLanguage(_ language: StaqWallet.SupportedLanguage)
  public static func makeStartView(user: StaqWallet.StaqWalletUser, onClose: @escaping () -> Swift.Void) -> some SwiftUICore.View
  
  public static func makeStartViewController(user: StaqWallet.StaqWalletUser, onClose: @escaping () -> Swift.Void) async -> UIKit.UIViewController
  public static func setPackagesNavigationCallback(_ callback: @escaping () -> Swift.Void)
  @objc deinit
}
extension StaqWallet.StaqWalletManager : TrustlessSDK.TrustlessDelegate {
  final public func didSessionExpired()
}
public struct StaqWalletUser : Swift.Hashable, Swift.Equatable {
  public enum UserType : Swift.String {
    case local
    case international
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let userId: Swift.String
  public let secret: Swift.String
  public let email: Swift.String
  public let userType: StaqWallet.StaqWalletUser.UserType?
  public let nationalId: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(userId: Swift.String, secret: Swift.String, email: Swift.String, userType: StaqWallet.StaqWalletUser.UserType? = nil, nationalId: Swift.String? = nil)
  #endif
  public static func == (a: StaqWallet.StaqWalletUser, b: StaqWallet.StaqWalletUser) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}





















public enum SupportedLanguage : Swift.String {
  case en
  case ar
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}



extension StaqWallet.StaqWalletTier0.WalletSourceType : Swift.Equatable {}
extension StaqWallet.StaqWalletTier0.WalletSourceType : Swift.Hashable {}
extension StaqWallet.StaqWalletTier0.WalletSourceType : Swift.RawRepresentable {}
extension StaqWallet.StaqWalletEnvironment : Swift.Equatable {}
extension StaqWallet.StaqWalletEnvironment : Swift.Hashable {}
extension StaqWallet.StaqWalletUser.UserType : Swift.Equatable {}
extension StaqWallet.StaqWalletUser.UserType : Swift.Hashable {}
extension StaqWallet.StaqWalletUser.UserType : Swift.RawRepresentable {}
extension StaqWallet.SupportedLanguage : Swift.Equatable {}
extension StaqWallet.SupportedLanguage : Swift.Hashable {}
extension StaqWallet.SupportedLanguage : Swift.RawRepresentable {}
